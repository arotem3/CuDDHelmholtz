#ifndef CUDDH_DDH_HPP
#define CUDDH_DDH_HPP

#include <cuda_runtime.h>
#include <functional>
#include <assert.h>
#include <unordered_set>

#include "Operator.hpp"
#include "EnsembleSpace.hpp"
#include "MassMatrix.hpp"
#include "linalg.hpp"

#include "HostDeviceArray.hpp"
#include "forall.hpp"

namespace cuddh
{
    class DDH : public Operator
    {
    public:
        /// @brief initialize domain decomposition Helmholtz approximate solver.
        /// @param omega the Helmholtz frequency
        /// @param h_a HOST ARRAY. The variable coefficient a
        /// @param fem H1Space. Mesh must be generated by Mesh2D::uniform_rect
        /// @param nx number of elements in x direction (as given to Mesh2D::uniform_rect)
        /// @param ny number of elements in y direction (as given to Mesh2D::uniform_rect)
        DDH(double omega, const double * h_a, const H1Space& fem, int nx, int ny);

        /// @brief y <- A * x where A is the approximate inverse of the
        /// Helmholtz equation estimated by a few iterations of the domain
        /// decomposition method.
        void action(const double * x, double * y) const override;

        /// NOT IMPLEMENTED
        void action(double c, const double * x, double * y) const override
        {
            cuddh_error("DDH::action(c, x, y) is not implemented");
        }

    private:
        int g_ndof;
        int g_elem;
        int n_basis;
        int n_domains;
        int n_lambda;
        int nt;
        int mx_n_lambda;
        int mx_dof;
        int mx_fdof;
        int mx_elem_per_dom;

        double omega;
        double dt;

        host_device_ivec _s_lambda;
        host_device_ivec _Bf;
        host_device_ivec _gI;
        host_device_ivec _sI;

        HostDeviceArray<float> _D; // differentiation matrix
        HostDeviceArray<float3> _g_tensor; // geometric factors for stiffness matrix computations
        HostDeviceArray<float> _m; // mass matrix 
        HostDeviceArray<float> _gmi; // global inverse mass
        HostDeviceArray<float> _H; // face mass matrix
        HostDeviceArray<float> _wh_filter; // omega / pi * (cos(omega * t) - 0.25) scaled by quadrature weights
        HostDeviceArray<float> _cs; // cos(omega t) on all half time steps
        HostDeviceArray<float> _sn; // sin(omega t) on all half time steps
        HostDeviceArray<float> _a; // variable coefficient a(x)

        mutable HostDeviceArray<float> _g_lambda; // global lambda vector
        mutable HostDeviceArray<float> _g_update; // global lambda updates

        std::unique_ptr<EnsembleSpace> efem;
    };
} // namespace cuddh

#endif
