#ifndef CUDDH_DDH_HPP
#define CUDDH_DDH_HPP

#include <cuda_runtime.h>
#include <functional>
#include <assert.h>
#include <unordered_set>

#include "cuddh_config.hpp"
#include "cuddh_error.hpp"
#include "Operator.hpp"
#include "EnsembleSpace.hpp"
#include "MassMatrix.hpp"
#include "linalg.hpp"

#include "HostDeviceArray.hpp"
#include "forall.hpp"

#include "gmres.hpp"

namespace cuddh
{
    struct WaveHoltz
    {
        double omega; // frequency
        double dt; // time step
        int nt; // number of time steps
        HostDeviceArray<float> K; // omega / pi * (cos(omega * t) - 0.25) scaled by quadrature weights
        HostDeviceArray<float> cs; // cos(omega t) on all half time steps
        HostDeviceArray<float> sn; // sin(omega t) on all half time steps
    };

    WaveHoltz init_waveholtz(double omega, double dt);

    class DDH : public SinglePrecisionOperator
    {
    public:
        /// @brief initialize domain decomposition Helmholtz approximate solver.
        /// @param omega the Helmholtz frequency
        /// @param h_a HOST ARRAY. The variable coefficient a
        /// @param fem H1Space. Mesh must be generated by Mesh2D::uniform_rect
        /// @param nx number of elements in x direction (as given to Mesh2D::uniform_rect)
        /// @param ny number of elements in y direction (as given to Mesh2D::uniform_rect)
        DDH(double omega, const double * h_a, const H1Space& fem, int nx, int ny);

        ~DDH() = default;

        /// return the number of degrees of freedom for the substructured problem.
        int size() const
        {
            return 2 * n_lambda;
        }

        // Compute the right hand side `b` of the substructured problem from the
        // forcing `f` of the Helmholtz problem (i.e. the right hand side of the
        // finite element problem).
        void rhs(const double * f, float * b) const;

        // extract the finite element solution `u` from the solution of the
        // substructured problem `lambda` and the Helmholtz forcing `f`.
        void postprocess(const float * lambda, const double * f, double * u) const;

        /// @brief y <- A * x where A is the approximate inverse of the
        /// Helmholtz equation estimated the domain decomposition method.
        void action(const float * x, float * y) const override;

    private:
        int g_ndof;
        int g_elem;
        int n_basis;
        int n_domains;
        int n_lambda;
        int mx_dof;
        int mx_fdof;
        int mx_elem_per_dom;

        host_device_ivec _Bf;
        host_device_ivec _gI;
        host_device_ivec _sI;

        HostDeviceArray<float> _D; // differentiation matrix
        HostDeviceArray<float3> _g_tensor; // geometric factors for stiffness matrix computations
        HostDeviceArray<float> _m; // mass matrix 
        HostDeviceArray<float> _gmi; // global inverse mass
        HostDeviceArray<float> _H; // face mass matrix
        HostDeviceArray<float> _a; // variable coefficient a(x)

        WaveHoltz W;

        std::unique_ptr<EnsembleSpace> efem;
    };
} // namespace cuddh

#endif
